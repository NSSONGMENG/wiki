### 定位内存地址的方法

温习一下四种段寄存器：
- 代码段地址寄存器`CS`，偏移地址寄存器`IP`
- 数据段地址寄存器`DS`，偏移地址寄存器`[0]`、`[bx]`
- 栈段地址寄存器 `SS`，偏移地址寄存器`SP`
- 扩展段地址寄存器`ES`


通常可以用[0]和[bx]结合DS或指定的段地址寄存器来指定物理内存地址。

## `and`和`or`指令
### and：逻辑与指令，按位进行与运算
```
mov al, 01100011B ;将01100011B送入ax的低8位，即al寄存器
and al, 01000010B ;将al的值和01000010B做逻辑与运算，结果存入al

执行后，al中的值为01000010B
```
### or：逻辑或指令，按位进行或运算
```
mov al, 01100011B ;将01100011B送入ax的低8位，即al寄存器
or  al, 01010010B ;将al的值和01010010B做逻辑或运算，结果存入al

执行后，al中的值为01110011B
```

## [bx+idata]
相比[bx]更灵活的当时指明一个内存单元，[bx+idata]表示偏移地址为(bx)+idata，即：BX中的数值+idata。段地址存储在DS中。

例如：
```
mov ax, [bx+200]
mov ax, [200+bx]
mov ax, 200[bx]
mov ax, [bx].200
以上四种形式是等价的
```
---
## `SI`和`DI`
si和di是8086CPU中和通用寄存器bx功能相近的寄存器，不能拆分成两个8位寄存器使用。

偏移地址的表示形式：
- 用一个常量表示偏移地址 如：`[idata]`
- 用一个变量表示偏移地址 如：`[bx]`、`[si]`、`[di]`、`[bp]`
- 用一个常量+一个变量表示 如：`[bx+idata]`、`idata[bx]`、`[bx].idata`
- 用两个变量表示偏移地址 如：`[bx+si]`、`[bx+di]`
> `[bx+si]`即`(bx) + (si)`（bx的值与si的值之和）作为偏移地址，`[bx+di]`同理。
- 用两个变量+一个常量表示 如`[bx+si+idata]`、`[bx+di+idata]`
> `[bx+si+idata]`即`[idata+bx+si]`、`idata[bx][si]`、`[bx].idata[si]`、`[bx][si].idata`

### 注
- 只有4个寄存器可以用在`[...]`中进行内存单元寻址， 即`bx`、`si`、`di`、`bp`
- 在`[...]`中这4个寄存器可以单独出现，或者只能以四种组合出现`bx和si`、`bx和di`、`bp和si`、`bp和di`
- 只要在`[...]`中使用`bp`，默认段地址寄存器就是`ss`，也可以显示的指定段地址寄存器

---
## `word ptr`和`byte ptr`
X ptr用于指明内存单元的长度，X可以是`word`或`byte`

- `word ptr`指明指令要访问的内存单元是一个字单元
```
mov word ptr ds:[0], 1  ; 操作的是(ds)*16+0和(ds)*16+1两个内存单元
inc word ptr [bx]
```

- `byte ptr`指明指令要访问的内存单元是字节单元
```
mov byte ptr ds:[0], 1  ; 操作的是(ds)*16一个内存单元
inc byte ptr [bx]
```

在没有寄存器参与的内存单元访问指令中，用`word ptr`和`byte ptr`显式的指明所要访问的内存单元的长度是很必要的。否则CPU无法得知所要访问的单元是字单元还是字节单元。
